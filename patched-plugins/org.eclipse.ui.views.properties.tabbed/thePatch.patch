Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/.settings/org.eclipse.jdt.core.prefs,v
retrieving revision 1.5
diff -u -r1.5 org.eclipse.jdt.core.prefs
--- .settings/org.eclipse.jdt.core.prefs	11 Sep 2007 13:46:07 -0000	1.5
+++ .settings/org.eclipse.jdt.core.prefs	21 Dec 2011 18:15:29 -0000
@@ -1,4 +1,4 @@
-#Tue Sep 11 09:39:14 EDT 2007
+#Wed Dec 21 19:13:17 CET 2011
 eclipse.preferences.version=1
 org.eclipse.jdt.core.builder.cleanOutputFolder=clean
 org.eclipse.jdt.core.builder.duplicateResourceTask=warning
@@ -7,28 +7,27 @@
 org.eclipse.jdt.core.circularClasspath=error
 org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
 org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.1
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.3
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
 org.eclipse.jdt.core.compiler.doc.comment.support=enabled
 org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
 org.eclipse.jdt.core.compiler.problem.deprecation=warning
 org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
 org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
 org.eclipse.jdt.core.compiler.problem.discouragedReference=error
 org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
 org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
 org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
 org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
 org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
 org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
 org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
 org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=warning
 org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
 org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
@@ -37,34 +36,59 @@
 org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
 org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
 org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
 org.eclipse.jdt.core.compiler.problem.missingJavadocComments=warning
 org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=disabled
 org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
 org.eclipse.jdt.core.compiler.problem.missingJavadocTags=warning
 org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=disabled
 org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
 org.eclipse.jdt.core.compiler.problem.missingSerialVersion=error
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
 org.eclipse.jdt.core.compiler.problem.noEffectAssignment=error
 org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
 org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=error
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
 org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=error
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
 org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
 org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
 org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=error
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
 org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=enabled
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
 org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.unnecessaryElse=warning
 org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
 org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=warning
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=enabled
 org.eclipse.jdt.core.compiler.problem.unusedImport=error
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
 org.eclipse.jdt.core.compiler.problem.unusedLocal=error
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=ignore
 org.eclipse.jdt.core.compiler.problem.unusedParameter=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
 org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=error
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.source=1.3
 org.eclipse.jdt.core.incompatibleJDKLevel=ignore
 org.eclipse.jdt.core.incompleteClasspath=error
Index: META-INF/MANIFEST.MF
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/META-INF/MANIFEST.MF,v
retrieving revision 1.16
diff -u -r1.16 MANIFEST.MF
--- META-INF/MANIFEST.MF	6 Jul 2010 14:01:15 -0000	1.16
+++ META-INF/MANIFEST.MF	21 Dec 2011 18:15:29 -0000
@@ -2,7 +2,7 @@
 Bundle-ManifestVersion: 2
 Bundle-Name: %Plugin.name
 Bundle-SymbolicName: org.eclipse.ui.views.properties.tabbed;singleton:=true
-Bundle-Version: 3.5.200.qualifier
+Bundle-Version: 3.5.201.qualifier
 Bundle-Activator: org.eclipse.ui.internal.views.properties.tabbed.TabbedPropertyViewPlugin
 Bundle-Vendor: %Plugin.providerName
 Bundle-Localization: plugin
Index: plugin.properties
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/plugin.properties,v
retrieving revision 1.2
diff -u -r1.2 plugin.properties
--- plugin.properties	1 Feb 2006 00:10:52 -0000	1.2
+++ plugin.properties	21 Dec 2011 18:15:28 -0000
@@ -9,7 +9,7 @@
 #     IBM Corporation - initial API and implementation
 ###############################################################################
 Plugin.name = Tabbed Properties View
-Plugin.providerName = Eclipse.org
+Plugin.providerName = Eclipse.org - BonitaSoft S.A.
 
 ExtPoint.propertyContributor = Property Contributor
 ExtPoint.propertyTabs = Property Tabs
Index: schema/propertySections.exsd
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/schema/propertySections.exsd,v
retrieving revision 1.3
diff -u -r1.3 propertySections.exsd
--- schema/propertySections.exsd	12 Apr 2007 17:42:41 -0000	1.3
+++ schema/propertySections.exsd	21 Dec 2011 18:15:29 -0000
@@ -117,6 +117,13 @@
                </documentation>
             </annotation>
          </attribute>
+         <attribute name="viewID" type="string">
+            <annotation>
+               <documentation>
+                  
+               </documentation>
+            </annotation>
+         </attribute>
       </complexType>
    </element>
 
Index: src/org/eclipse/ui/internal/views/properties/tabbed/view/OverridableTabListContentProvider.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/src/org/eclipse/ui/internal/views/properties/tabbed/view/OverridableTabListContentProvider.java,v
retrieving revision 1.3
diff -u -r1.3 OverridableTabListContentProvider.java
--- src/org/eclipse/ui/internal/views/properties/tabbed/view/OverridableTabListContentProvider.java	6 Jul 2010 14:00:42 -0000	1.3
+++ src/org/eclipse/ui/internal/views/properties/tabbed/view/OverridableTabListContentProvider.java	21 Dec 2011 18:15:29 -0000
@@ -40,7 +40,7 @@
  * @author Anthony Hunter
  * @since 3.4
  */
-class OverridableTabListContentProvider extends TabListContentProvider
+public class OverridableTabListContentProvider extends TabListContentProvider
 		implements IOverridableTabListContentProvider, ITabSelectionListener {
 
 	/**
Index: src/org/eclipse/ui/internal/views/properties/tabbed/view/TabDescriptor.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/src/org/eclipse/ui/internal/views/properties/tabbed/view/TabDescriptor.java,v
retrieving revision 1.3
diff -u -r1.3 TabDescriptor.java
--- src/org/eclipse/ui/internal/views/properties/tabbed/view/TabDescriptor.java	6 Jul 2010 14:00:42 -0000	1.3
+++ src/org/eclipse/ui/internal/views/properties/tabbed/view/TabDescriptor.java	21 Dec 2011 18:15:29 -0000
@@ -26,6 +26,7 @@
 import org.eclipse.ui.views.properties.tabbed.AbstractTabDescriptor;
 import org.eclipse.ui.views.properties.tabbed.ISectionDescriptor;
 
+
 /**
  * Represents the default implementation of a tab descriptor on the tabbed
  * property tabs extensions.
Index: src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistry.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistry.java,v
retrieving revision 1.6
diff -u -r1.6 TabbedPropertyRegistry.java
--- src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistry.java	6 Jul 2010 14:00:42 -0000	1.6
+++ src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistry.java	21 Dec 2011 18:15:29 -0000
@@ -13,10 +13,10 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
-
-import com.ibm.icu.text.MessageFormat;
+import java.util.Map;
 
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IConfigurationElement;
@@ -24,11 +24,9 @@
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Platform;
 import org.eclipse.core.runtime.Status;
-
 import org.eclipse.jface.viewers.ILabelProvider;
 import org.eclipse.jface.viewers.ISelection;
 import org.eclipse.jface.viewers.IStructuredContentProvider;
-
 import org.eclipse.ui.IWorkbenchPart;
 import org.eclipse.ui.internal.views.properties.tabbed.TabbedPropertyViewPlugin;
 import org.eclipse.ui.internal.views.properties.tabbed.TabbedPropertyViewStatusCodes;
@@ -41,11 +39,14 @@
 import org.eclipse.ui.views.properties.tabbed.ITabDescriptorProvider;
 import org.eclipse.ui.views.properties.tabbed.ITypeMapper;
 
+import com.ibm.icu.text.MessageFormat;
+
 /**
  * Provides information about the tabbed property extension points. Each tabbed
  * property registry is associated with a unique contributor ID.
  * 
  * @author Anthony Hunter
+ * @author Aurelien Pupier : BUGFIX 219578
  */
 public class TabbedPropertyRegistry {
 
@@ -60,11 +61,11 @@
 
 	private static final String EXTPT_TABS = "propertyTabs"; //$NON-NLS-1$
 
-	private static final String EXTPT_SECTIONS = "propertySections"; //$NON-NLS-1$
+	protected static final String EXTPT_SECTIONS = "propertySections"; //$NON-NLS-1$
 
 	private static final String ELEMENT_TAB = "propertyTab"; //$NON-NLS-1$
 
-	private static final String ELEMENT_SECTION = "propertySection"; //$NON-NLS-1$
+	protected static final String ELEMENT_SECTION = "propertySection"; //$NON-NLS-1$
 
 	private static final String ELEMENT_PROPERTY_CATEGORY = "propertyCategory"; //$NON-NLS-1$
 
@@ -72,7 +73,7 @@
 
 	private static final String ATT_CONTRIBUTOR_ID = "contributorId"; //$NON-NLS-1$
 
-	private static final String ATT_TYPE_MAPPER = "typeMapper"; //$NON-NLS-1$
+	private static final String ATT_TYPE_MAPPER = "typeMapper"; //$NON-NLS-1$	
 
 	private static final String ATT_LABEL_PROVIDER = "labelProvider"; //$NON-NLS-1$
 
@@ -444,7 +445,7 @@
 		List sorted = new ArrayList();
 		int categoryIndex = 0;
 		for (int i = 0; i < propertyCategories.size(); i++) {
-			List categoryList = new ArrayList();
+			List<TabDescriptor> categoryList = new ArrayList<TabDescriptor>();
 			String category = (String) propertyCategories.get(i);
 			int topOfCategory = categoryIndex;
 			int endOfCategory = categoryIndex;
@@ -453,28 +454,56 @@
 							.equals(category)) {
 				endOfCategory++;
 			}
-			for (int j = topOfCategory; j < endOfCategory; j++) {
+			
+			Map<String, List<TabDescriptor>> mapOfAfterTab = new HashMap<String, List<TabDescriptor>>();
+						
+			for (int j = topOfCategory; j < endOfCategory; j++) {				
 				TabDescriptor tab = (TabDescriptor) tabs.get(j);
-				if (tab.getAfterTab().equals(TOP)) {
-					categoryList.add(0, tabs.get(j));
-				} else {
-					categoryList.add(tabs.get(j));
+				String afterTab;
+				if((afterTab = tab.getAfterTab()) == "" ){ //$NON-NLS-1$
+					afterTab = "no after tab"; //$NON-NLS-1$
 				}
-			}
-			Collections.sort(categoryList, new Comparator() {
-
-				public int compare(Object arg0, Object arg1) {
-					TabDescriptor one = (TabDescriptor) arg0;
-					TabDescriptor two = (TabDescriptor) arg1;
-					if (two.getAfterTab().equals(one.getId())) {
-						return -1;
-					} else if (one.getAfterTab().equals(two.getId())) {
-						return 1;
+				List<TabDescriptor> tempList = mapOfAfterTab.get(afterTab);
+				if(tempList == null){
+					tempList = new ArrayList<TabDescriptor>();
+					mapOfAfterTab.put(afterTab, tempList);
+				}
+				tempList.add(tab);
+			}		
+			
+			/*Set to the beginning of the list: the afterTab top and no afterTab*/
+			List<TabDescriptor> toAdd;
+			if((toAdd = mapOfAfterTab.get(TOP)) != null){
+				categoryList.addAll(toAdd);
+				mapOfAfterTab.remove(TOP);
+			}
+			if((toAdd = mapOfAfterTab.get("no after tab")) != null){ //$NON-NLS-1$
+				categoryList.addAll(toAdd);
+				mapOfAfterTab.remove("no after tab"); //$NON-NLS-1$
+			}
+			
+			
+			for(int k = 0; k < endOfCategory - topOfCategory +1;k++){
+				if(categoryList.size() > k){
+					TabDescriptor current = categoryList.get(k);
+					if((toAdd = mapOfAfterTab.get(current.getId())) != null){
+						categoryList.addAll(toAdd);
+						mapOfAfterTab.remove(current.getId());
+					}
+				} else {
+					//check if there is other
+					if(mapOfAfterTab.keySet().size() != 0){
+						String key = mapOfAfterTab.keySet().iterator().next();
+						categoryList.addAll(mapOfAfterTab.get(key));
+						mapOfAfterTab.remove(key);
 					} else {
-						return 0;
+						//all is already added
+						break;
 					}
-				}
-			});
+				}			
+			}
+		
+
 			for (int j = 0; j < categoryList.size(); j++) {
 				sorted.add(categoryList.get(j));
 			}
Index: src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryFactory.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryFactory.java,v
retrieving revision 1.5
diff -u -r1.5 TabbedPropertyRegistryFactory.java
--- src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryFactory.java	31 Jan 2011 13:15:09 -0000	1.5
+++ src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryFactory.java	21 Dec 2011 18:15:29 -0000
@@ -71,7 +71,14 @@
 		CacheData data = (CacheData) idToCacheData.get(key);
 		if (data == null) {
 			data = new CacheData();
-			data.registry = new TabbedPropertyRegistry(key);
+			/*use here custom TabbedPropertyRegistry
+			 * that are aware of viewID in which they are used*/
+			if(key.equals("org.bonitasoft.studio.diagram") //$NON-NLS-1$
+					|| key.equals("org.bonitasoft.studio.diagram.form")){ //$NON-NLS-1$
+				data.registry = new TabbedPropertyRegistryViewAware(key);
+			} else {	
+				data.registry = new TabbedPropertyRegistry(key);
+			}
 			data.references = new ArrayList(5);
 			idToCacheData.put(key, data);
 		}
Index: src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryViewAware.java
===================================================================
RCS file: src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryViewAware.java
diff -N src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryViewAware.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/eclipse/ui/internal/views/properties/tabbed/view/TabbedPropertyRegistryViewAware.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,133 @@
+/**
+ * Copyright (C) 2010 BonitaSoft S.A.
+ * BonitaSoft, 31 rue Gustave Eiffel - 38000 Grenoble
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2.0 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.eclipse.ui.internal.views.properties.tabbed.view;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.core.runtime.IConfigurationElement;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.ui.IWorkbenchPart;
+import org.eclipse.ui.views.properties.tabbed.ISectionDescriptor;
+import org.eclipse.ui.views.properties.tabbed.ITabDescriptor;
+
+/**
+ * @since 3.5
+ *
+ */
+public class TabbedPropertyRegistryViewAware extends TabbedPropertyRegistry {
+
+	/**
+	 * @param id
+	 */
+	protected TabbedPropertyRegistryViewAware(String id) {
+		super(id);
+	}
+	
+	/**
+	 * Reads property section extensions. Returns all section descriptors for
+	 * the current contributor id or an empty array if none is found.
+	 * @param viewId
+	 * 	take care in which view it is
+	 */
+	protected ISectionDescriptor[] readSectionDescriptors(String viewId) {
+		List<ISectionDescriptor> result = new ArrayList<ISectionDescriptor>();
+		IConfigurationElement[] extensions = getConfigurationElements(EXTPT_SECTIONS);
+		for (int i = 0; i < extensions.length; i++) {
+			IConfigurationElement extension = extensions[i];
+			IConfigurationElement[] sections = extension
+					.getChildren(ELEMENT_SECTION);
+			for (int j = 0; j < sections.length; j++) {
+				IConfigurationElement section = sections[j];
+				String sectionViewId = section.getAttribute("viewID"); //$NON-NLS-1$
+				if(sectionViewId != null && sectionViewId.equals(viewId)){
+					ISectionDescriptor descriptor = new SectionDescriptor(section,
+						typeMapper);
+					result.add(descriptor);
+				}
+			}
+		}
+		return result.toArray(new ISectionDescriptor[result.size()]);
+	}
+	
+	/**
+	 * Populates the given tab descriptors with section descriptors.
+	 */
+	protected void populateWithSectionDescriptors(List<?> aTabDescriptors, String viewId) {
+		ISectionDescriptor[] sections = null;
+		if (sectionDescriptorProvider != null) {
+			sections = sectionDescriptorProvider.getSectionDescriptors();
+		} else {
+			sections = readSectionDescriptors(viewId);
+		}
+		for (int i = 0; i < sections.length; i++) {
+			ISectionDescriptor section = sections[i];
+			appendToTabDescriptor(section, aTabDescriptors);
+		}
+	}
+	
+	/**
+	 * Reads property tab extensions. Returns all tab descriptors for the
+	 * current contributor id or an empty array if none is found.
+	 */
+	protected ITabDescriptor[] getAllTabDescriptors(String viewId) {
+		//TODO: we no more use a cached tabDescriptors, might cause issue performance
+		//if (tabDescriptors == null) {
+			List<ITabDescriptor> temp = readTabDescriptors();
+			populateWithSectionDescriptors(temp, viewId);
+			temp = sortTabDescriptorsByCategory(temp);
+			temp = sortTabDescriptorsByAfterTab(temp);
+			tabDescriptors = temp
+					.toArray(new TabDescriptor[temp.size()]);
+		//}
+		return tabDescriptors;
+	}
+	
+	/**
+	 * Returns all section descriptors for the provided selection.
+	 * 
+	 * @param part
+	 *            the workbench part containing the selection
+	 * @param selection
+	 *            the current selection.
+	 * @param viewID
+	 *            The view in which we want the get tab
+	 * @return all section descriptors.
+	 */
+	public ITabDescriptor[] getTabDescriptors(IWorkbenchPart part,
+			ISelection selection, String viewID) {
+		if (selection == null || selection.isEmpty()) {
+			return EMPTY_DESCRIPTOR_ARRAY;
+		}
+
+		ITabDescriptor[] allDescriptors = null;
+		if (tabDescriptorProvider == null) {
+			allDescriptors = getAllTabDescriptors(viewID);
+		} else {
+			allDescriptors = tabDescriptorProvider.getTabDescriptors(part,
+					selection);
+		}
+
+		ITabDescriptor[] result = filterTabDescriptors(allDescriptors, part,
+				selection);
+		return result;
+	}
+	
+}
Index: src/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetPage.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.ui.views.properties.tabbed/src/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetPage.java,v
retrieving revision 1.17
diff -u -r1.17 TabbedPropertySheetPage.java
--- src/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetPage.java	9 Jan 2009 18:14:59 -0000	1.17
+++ src/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetPage.java	21 Dec 2011 18:15:31 -0000
@@ -75,7 +75,7 @@
 
 	private ITabbedPropertySheetPageContributor contributor;
 
-	private TabbedPropertyRegistry registry;
+	protected TabbedPropertyRegistry registry;
 
 	private ITabbedPropertySheetPageContributor selectionContributor = null;
 
@@ -87,11 +87,11 @@
 
 	protected IStructuredContentProvider tabListContentProvider;
 
-	private ISelection currentSelection;
+	protected ISelection currentSelection;
 
 	private boolean activePropertySheet;
 
-	private TabbedPropertyViewer tabbedPropertyViewer;
+	protected TabbedPropertyViewer tabbedPropertyViewer;
 
 	private TabContents currentTab;
 
@@ -99,9 +99,9 @@
 
 	private Map tabToComposite;
 
-	private List selectionQueue;
+	protected List selectionQueue;
 
-	private boolean selectionQueueLocked;
+	protected boolean selectionQueueLocked;
 
 	private List tabSelectionListeners;
 
@@ -195,31 +195,39 @@
 				// can not cache based on the id - tabs may have the same id,
 				// but different section depending on the selection
 				tab = (TabContents) descriptorToTab.get(descriptor);
-
+				
+				/*Need to create tab more often than previously...*/
+				//TODO: improve creation of tab
+				if(tab == null){
+					tab = createTab(descriptor);
+					descriptorToTab.put(descriptor, tab);
+				}
+				
 				if (tab != currentTab) {
 					hideTab(currentTab);
 				}
+				if(tab != null){
+					Composite tabComposite = (Composite) tabToComposite.get(tab);
+					if (tabComposite == null) {
+						tabComposite = createTabComposite();
+						tab.createControls(tabComposite,
+								TabbedPropertySheetPage.this);
+						// tabAreaComposite.layout(true);
+						tabToComposite.put(tab, tabComposite);
+					}
+					// force widgets to be resized
+					tab.setInput(tabbedPropertyViewer.getWorkbenchPart(),
+							(ISelection) tabbedPropertyViewer.getInput());
 
-				Composite tabComposite = (Composite) tabToComposite.get(tab);
-				if (tabComposite == null) {
-					tabComposite = createTabComposite();
-					tab.createControls(tabComposite,
-						TabbedPropertySheetPage.this);
-					// tabAreaComposite.layout(true);
-					tabToComposite.put(tab, tabComposite);
-				}
-				// force widgets to be resized
-				tab.setInput(tabbedPropertyViewer.getWorkbenchPart(),
-					(ISelection) tabbedPropertyViewer.getInput());
+					// store tab selection
+					storeCurrentTabSelection(descriptor.getLabel());
 
-				// store tab selection
-				storeCurrentTabSelection(descriptor.getLabel());
+					if (tab != currentTab) {
+						showTab(tab);
+					}
 
-				if (tab != currentTab) {
-					showTab(tab);
+					tab.refresh();
 				}
-
-				tab.refresh();
 			}
 			tabbedPropertyComposite.getTabComposite().layout(true);
 			currentTab = tab;
@@ -620,7 +628,7 @@
 	/**
 	 * Returns the last known selected tab for the given input.
 	 */
-	private int getLastTabSelection(IWorkbenchPart part, ISelection input) {
+	protected int getLastTabSelection(IWorkbenchPart part, ISelection input) {
 		ITabDescriptor[] descriptors = registry.getTabDescriptors(part, input);
 		if (descriptors.length != 0) {
 			for (Iterator iter = selectionQueue.iterator(); iter.hasNext();) {
@@ -706,7 +714,7 @@
 		return result;
 	}
 
-	private void setInput(IWorkbenchPart part, ISelection selection) {
+	protected void setInput(IWorkbenchPart part, ISelection selection) {
 		if (selection.equals(currentSelection)) {
 			return;
 		}
@@ -823,7 +831,7 @@
 	/**
 	 * Update the title bar of the contributor has a label provider.
 	 */
-	private void refreshTitleBar() {
+	protected void refreshTitleBar() {
 		if (hasTitleBar) {
 			TabbedPropertyTitle title = tabbedPropertyComposite.getTitle();
 			if (currentTab == null) {
@@ -892,7 +900,7 @@
 	 * @param selection
 	 *            the current selection in the active workbench part.
 	 */
-	private void validateRegistry(ISelection selection) {
+	protected void validateRegistry(ISelection selection) {
 		if (selection == null) {
 			return;
 		}
